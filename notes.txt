I'm looking at how dataflow expression editing can be added to charmapper.
One of the main ideas is that we can have three modes for editing expressions:
* Interactive mode
  * There are predefined expression types and all the inputs for that
    expression type are presented like a propery editor.
* Expression mode
  * A text area is provided to type in the expression.
  * Expressions are
    a = b + c;
    d = e + f;
    a + d
* Node mode
  * The expression is represented as a set of nodes that represent
    an expression tree.
  * Each node has a single output and zero or more inputs.
  * Outputs can be expanded to extract members.
  * The default operation for dragging on a node is making a connection.
    * Moving a node involves selecting it, which produces something like
      a title-bar that you can drag to move the node.
---
If we have an input that is a function, it feels like an output.  For
example, if we have an "if" expression, the "then" and "else" parts are
parameters which specify functions to evaluate, but they feel like
outputs.

Drawing a square

draw(square(a,b))

let square(lower_left_corner,upper_right_corner) = (
  let min_x = lower_left_corner.x;
  let min_y = lower_left_corner.y;
  let max_x = upper_right_corner.x;
  let max_y = upper_right_corner.y;
  let upper_left_corner = Point(x=min_x,y=max_y);
  let lower_right_corner = Point(x=max_x,y=min_y);
  let left_edge = Line(start=upper_left_corner,end=lower_left_corner);
  let right_edge = Line(start=lower_right_corner,end=upper_right_corner);
  let top_edge = Line(start=upper_right_corner,end=upper_left_corner);
  let bottom_edge = Line(start=lower_left_corner,end=lower_right_corner);
  [
    left_edge,
    right_edge,
    top_edge,
    bottom_edge
  ]
)

let lines_for_square(lower_left_corner,upper_right_corner) = (
  let Point = Object;
  let Line = Object;
  let (
    let (
      let min_x = lower_left_corner.x;
      let min_y = lower_left_corner.y;
      let max_x = upper_right_corner.x;
      let max_y = upper_right_corner.y;
      upper_left_corner = Point(x=min_x,y=max_y),
      lower_right_corner = Point(x=max_x,y=min_y)
    );
    left_edge = Line(start=upper_left_corner,end=lower_left_corner),
    right_edge = Line(start=lower_right_corner,end=upper_right_corner),
    top_edge = Line(start=upper_right_corner,end=upper_left_corner),
    bottom_edge = Line(start=lower_left_corner,end=lower_right_corner)
  )
  [
    left_edge,
    right_edge,
    top_edge,
    bottom_edge
  ]
)

---
I like the way this looks:
  http://rawkes.com/media/noflo-introduction/quartz-composer.png

Maybe I should work on a node system that has both inputs and outputs.
Inputs are names.
Outputs are expressions.
Seems like you could do a decent amount with just that.
----
Nodes have regular inputs and outputs on the left and right.
Nodes have an environment input on the top and an environment output on
the bottom.

A special code node contains internal logic.
It only has one output, which is the code.
Internally, it has an env input at the top and an env output at the bottom.

Let's call it a block.

You can have text blocks or diagram blocks.

{a = x;b = y;} // text block

A block is a function which takes an environment and returns an environment.

Functions can be created from blocks:
  function(inputs=['x','y'],outputs=['a','b'],code={a=x;b=y;})

You could have a node which was a sequence of statements.

  *|let x = $| 
  *|let y = $| 
   |      x+y|*

$ represents an input.  If the $ appears in the statement, then there is
an input connector there.
If the statement has a value, then an output connector appears.

A statement may have both an input and an output connector.
  *|$ + 5|*

Example of extracting x,y members from a point:

  *|let p = $|
   |      p.x|*
   |      p.y|*

It seems like we have two basic operations: Abstract and Apply.
Abstract creates a function, Apply applies a function.

Visually, we can takes nodes and abstract them, which creates a function
which takes an environment and returns and environment.


function(inputs=['a','b'],outputs=['x','y'],code={x=a;y=b;})(a=1,b=2)

this produces the tuple (x=1,y=2)

We can have a function node, we coverts a block into a function.

* Creating a block
* Creating a function from a block
* Applying a function

*|let a=$|
*|let b=$|
     |
  |a + b|*

We have to be careful about scope.  Do we want a statement node to return 
a modified verison of the original environment, or to return a new
environment?


*|x=input   |
*|y=input   |
 |output x+y|*

*|condition=input                                  |
*|then_block=input                                 |
*|else_block=input                                 |
 |then_block(env) if condition else else_block(env)|*

*|if input:  |
*|  exec     |
 |else:      |
*|  exec     |

 |ikPos(         |
*|  global=input,|
*|  local=input, |
*|  weight=input |
 |)              |

 |output list(|*
*|  input,    |
*|  input,    |
*|  input     |
 |)           |

Maybe if we have an output inside a loop, it creates a list:

  *|for x in input:|
   |  output x     |*--*|list(*input)|*

Inputting an outputting lists:

  *|let [x,y,z]=input   |
   |      output [z,y,x]|*

We could have special connectors which look like outputs, but are actually
inputs.  They form a block from whatever they are connected to.

Should we have a scope node that creates a new environment with the current
environment as its parent?

|let y = 4      |
|let x = 4      |
|scope{continue}|*----+
|output y       |*----|---- (6)
|output x       |*----|---- (4)
                      *
                 |let x = 5|
                 |y = 6    |


If we have continuations, can we create blocks like this?

      |let block={continue}|*---- (connect to nodes which form the block)
      |        output block|*---- (this is the resulting block)


 *|let yes=input                  |
 *|let no=input                   |
 *|let condition=input            |
  |output yes if condition else no|*

If nodes become disconnected because we temporarily have an invalid value,
it is inconvenient.

Maybe we hold on the the connection if there is one, but otherwise, we
add or remove the connector on each keystroke.


I think I want to start integrating this with Qt widgets.
I want to be able to add a slider, then put in some logic that does something
with the slider, and then show the result.

Maybe something where we add three sliders for R,G,B, then use a diagram
to turn those into a color, and then display the color.
---
It seems appealing to have it where the items in the tree represent
expressions, and the child items represent variables that can be used in
those expressions.
---
Need to have named inputs.
Maybe the inputs should be independent of the lines:
i.e. if you use $a on various lines, they all refer to the same input.
---
Maybe if we right-click on X we get a menu that lets us convert it to
a diagram.
---
It would be neat if you could select some text in a node, then drag it out
and have it create a new node with the text, replace the text in the original
node with a $ and attach the new node's output to a new input connector.
---
Eventually.  I think we'll want to be able to have diagrams that generate
new items in the tree.  I can imagine a diagram whose output is a list of
tree items.

Let's say we wanted to create a spline, and then generate a baked version
of that spline that then goes into the tree.

Or we want to create a tool that lets you add a new key to the spline.

Maybe a good thing to work on is being able to draw a spline.
We'll need a way to create a window, create a drawing area within the
window, and then provide a diagram that generates what we will draw.
---
Need a way to make paths based on labels instead of indices.
This will make it easier to have tests like testAddingBodies() be stable.

We may end up wanting to create handles for items in the tree of a specific
type, so that when we visit the wrapper, we automatically get the wrapper
of the appropriate type.  Not clear if it is worth it yet.

It would be convenient if we had Wrapper::accept methods which took
functions for specific types of wrappers.  It would call the function
if the wrapper had the appropriate type, and assert otherwise.

---
What does it mean to apply a charmap? Are we creating a new layer of motion?
  * It seems like if we have a charmap and then remove it, the motion should
    reset.
  * I think we want the body properties to be displayed as they are after
    the charmap is applied, but we shouldn't be able to change those.
  * Should we have a place where we change what we are seeing?
    * Change between viewing uncharmapped vs charmapped motion.
    * Seems like it would be limiting.  Instead, we could disable things when
      we want to see what it looks like.
  * Maybe when we add a charmap we have a child of the charmap, which is
    the state of the scene after the charmap is applied.
  * Maybe the scene viewer includes its own tree where you can view the
    properties of the scene as they are displayed (after charmapping).
---
If we change the name of a body in the tree editor, it should change in
the scene view.

Need a test where when we set the target body to None it takes away the
effect of charmapper.

Need to switch to using sysvars for scene state.

Finish use of USE_POINT2D_MAP macro

I think we need a WrapperData that goes with the SceneWrapper so we don't have
to pass a lot of individual parameters.
* The scene
* The notify function
* THe frame

Scene needs a background frame.

Since a charmapper can affect multiple scenes, we'll need to pass a list
of frames to the Charmapper::apply()

Seems like we need the target_body_ptr to have both a scene and a body.
We need some way to find the appropriate frame.
Having a scene index would be a natural way to do it, then we could have
a parallel array of frames for the scenes.

Having a map from scene to frame would be a bit more expressive.  Maybe it
is best to do that initially.

Add a scene pointer to the Charmapper::BodyLink

Looks like we should be passing around BodyLinks instead of separate scene
and body pointers.
