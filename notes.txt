I'm looking at how dataflow expression editing can be added to charmapper.
One of the main ideas is that we can have three modes for editing expressions:
* Interactive mode
  * There are predefined expression types and all the inputs for that
    expression type are presented like a propery editor.
* Expression mode
  * A text area is provided to type in the expression.
  * Expressions are
    a = b + c;
    d = e + f;
    a + d
* Node mode
  * The expression is represented as a set of nodes that represent
    an expression tree.
  * Each node has a single output and zero or more inputs.
  * Outputs can be expanded to extract members.
  * The default operation for dragging on a node is making a connection.
    * Moving a node involves selecting it, which produces something like
      a title-bar that you can drag to move the node.
----
Nodes have regular inputs and outputs on the left and right.
Nodes have an environment input on the top and an environment output on
the bottom.

A special code node contains internal logic.
It only has one output, which is the code.
Internally, it has an env input at the top and an env output at the bottom.

Let's call it a block.

You can have text blocks or diagram blocks.

{a = x;b = y;} // text block

A block is a function which takes an environment and returns an environment.

Functions can be created from blocks:
  function(inputs=['x','y'],outputs=['a','b'],code={a=x;b=y;})

*|condition=$                        |
*|then_block=$                       |
*|else_block=$                       |
 |if(condition,then_block,else_block)|*

*|if input:  |
*|  exec     |
 |else:      |
*|  exec     |

Maybe if we have an output inside a loop, it creates a list:

  *|for x in input:|
   |  output x     |*--*|list(*input)|*

Inputting an outputting lists:

  *|let [x,y,z]=input   |
   |      output [z,y,x]|*

We could have special connectors which look like outputs, but are actually
inputs.  They form a block from whatever they are connected to.

Should we have a scope node that creates a new environment with the current
environment as its parent?

|let y = 4      |
|let x = 4      |
|scope{continue}|*----+
|output y       |*----|---- (6)
|output x       |*----|---- (4)
                      *
                 |let x = 5|
                 |y = 6    |


If we have continuations, can we create blocks like this?

      |let block={continue}|*---- (connect to nodes which form the block)
      |        output block|*---- (this is the resulting block)


 *|let yes=input                  |
 *|let no=input                   |
 *|let condition=input            |
  |output yes if condition else no|*

I think I want to start integrating this with Qt widgets.
I want to be able to add a slider, then put in some logic that does something
with the slider, and then show the result.

Maybe something where we add three sliders for R,G,B, then use a diagram
to turn those into a color, and then display the color.
---
It would be neat if you could select some text in a node, then drag it out
and have it create a new node with the text, replace the text in the original
node with a $, and attach the new node's output to a new input connector.
---
Maybe a good thing to work on is being able to draw a spline.
We'll need a way to create a window, create a drawing area within the
window, and then provide a diagram that generates what we will draw.
---
If a node in a diagram gets wider, it should push nodes that are connected
to it to the right.
---
Be able to remove variable min/max

Having the worldwrapper_test use a FakeTree should make the tests easier.
We should now be able to use the TreeUpdatingObserver.
---
I'd like to be able to assign new variables when evaluating a diagram.
Currently, when we are evaluating a diagram node, we have an input
environment, and it is const.  If we were to assign a value to a variable,
we'd really want to create a new environment and not modify the existing
environment.

It seems like these environments will be part of the diagram state.
Maybe we have a set of unique_ptrs to environments that we've created.

How does this work at the individual level of evaluateExpression()?

ExpressionEvaluatorData could have an environment allocator of some sort
so that when evaluateExpression() decides it needs a new environment it
has a way to do it.  We could be storing these environments inside the
DiagramState.

We could also say that evaluateExpression() takes an input environment
and an expression string and outputs an environment and a value.
The output environment may be the same as the input environment, or it
may be a new environment.

evaluateLineText() is probably where we'd handle an assignment, so that
an assignment isn't considered an expression.

Need executor::newEnvironment()

The DiagramExecutor needs to be able to allocate an environment from the
DiagramState, but it doesn't have access to the DiagramState.  How do
error end up being kept in the diagram state?
  evaluateDiagramNodeLine() is what stores the error in the diagram state.
  It has access to both the DiagramState and the Executor.  It calls
  evaluateLineText().

Inputs aren't clearly associated with lines.
* If you have two lines, and the first line has no inputs, and the second
  line has two inputs, it looks like the first input goes with the first
  line and the second input goes with the second line.  It would be better
  if the lines were spaced such that it was clear which inputs went with
  each line.
