I'm looking at how dataflow expression editing can be added to charmapper.
One of the main ideas is that we can have three modes for editing expressions:
* Interactive mode
  * There are predefined expression types and all the inputs for that
    expression type are presented like a propery editor.
* Expression mode
  * A text area is provided to type in the expression.
  * Expressions are
    a = b + c;
    d = e + f;
    a + d
* Node mode
  * The expression is represented as a set of nodes that represent
    an expression tree.
  * Each node has a single output and zero or more inputs.
  * Outputs can be expanded to extract members.
  * The default operation for dragging on a node is making a connection.
    * Moving a node involves selecting it, which produces something like
      a title-bar that you can drag to move the node.
----
Nodes have regular inputs and outputs on the left and right.
Nodes have an environment input on the top and an environment output on
the bottom.

A special code node contains internal logic.
It only has one output, which is the code.
Internally, it has an env input at the top and an env output at the bottom.

Let's call it a block.

You can have text blocks or diagram blocks.

{a = x;b = y;} // text block

A block is a function which takes an environment and returns an environment.

Functions can be created from blocks:
  function(inputs=['x','y'],outputs=['a','b'],code={a=x;b=y;})

*|condition=$                        |
*|then_block=$                       |
*|else_block=$                       |
 |if(condition,then_block,else_block)|*

*|if input:  |
*|  exec     |
 |else:      |
*|  exec     |

Maybe if we have an output inside a loop, it creates a list:

  *|for x in input:|
   |  output x     |*--*|list(*input)|*

Inputting an outputting lists:

  *|let [x,y,z]=input   |
   |      output [z,y,x]|*

We could have special connectors which look like outputs, but are actually
inputs.  They form a block from whatever they are connected to.

Should we have a scope node that creates a new environment with the current
environment as its parent?

|let y = 4      |
|let x = 4      |
|scope{continue}|*----+
|output y       |*----|---- (6)
|output x       |*----|---- (4)
                      *
                 |let x = 5|
                 |y = 6    |


If we have continuations, can we create blocks like this?

      |let block={continue}|*---- (connect to nodes which form the block)
      |        output block|*---- (this is the resulting block)


 *|let yes=input                  |
 *|let no=input                   |
 *|let condition=input            |
  |output yes if condition else no|*

I think I want to start integrating this with Qt widgets.
I want to be able to add a slider, then put in some logic that does something
with the slider, and then show the result.

Maybe something where we add three sliders for R,G,B, then use a diagram
to turn those into a color, and then display the color.
---
It would be neat if you could select some text in a node, then drag it out
and have it create a new node with the text, replace the text in the original
node with a $, and attach the new node's output to a new input connector.
---
Maybe a good thing to work on is being able to draw a spline.
We'll need a way to create a window, create a drawing area within the
window, and then provide a diagram that generates what we will draw.
---
We could have it such that a node always represents one statement, but
we can have nodes that stack vertically.   If we grab a lower node, it
will disconnect from the upper node, but if we grab an upper node, it will
move all nodes below it.
---
If a node in a diagram gets wider, it should push nodes that are connected
to it to the right.
---
It would be good to have a way to move bodies in the scene.
We could just consider this to be a basic function of the scene.  We would
just need a way to have a callback so when a body is moved, we can
update the tree.

This is the first time that something wrapped has been able to change
without using a wrapper.   The only access the tree editor has to
the scene is through the wrapper, so we have to have a way to install
a callback through the wrapper.
* I guess one alternative would be a polling mechanism, where we
  ask the wrapper for tree changes, but this seems awkward.  The wrapper
  would have to buffer any changes until it was asked for them.
* This isn't really that different from the observer mechanism we have
  for diagrams, so we just need a way to be able to ask a wrapper
  for an observer.
  * TreeObserverPtr Wrapper::makeObserver()
  * We're already using the term Observer for the interface which
    handles tree changes.  I think we should rename it to something
    like TreeChangeHandler, or maybe TreeInterface.


* Maybe instead of giving a Wrapper to the TreeEditor, we give it a
  Wrapper observer.  The TreeEditor then sets the wrapper observer's
  listener so that it can be notified when wrapper hierarchy changes.
  
struct Wrapper {
};


struct Observer {
  Listener &listener;
  Wrapper &wrapper;

  Observer(Subject &,Listener &);
  ~Observer();

  Observer(const Observer &) = delete;
  void operator=(const Observer &) = delete;
};


struct TreeMediator {
  ObserverPtr observer_ptr;
  Tree &tree;

  struct Listener : TreeListener {
    TreeMediator &mediator;

    void itemAdditem() override {
      mediator.treeItemAdded();
    }
  };

  void setObserver(ObserverPtr observer_ptr_arg)
  {
    observer_ptr = std::move(observer_ptr_arg);

    if (observer_ptr) {
      observer_ptr->listener_ptr = &listener;
    }
  }
};


The TreeEditor::setWorldState() should be removed once the TreeEditor can
observe the wrapper state changes.  The main window can then just apply
the new state to the wrapper and the tree editor should automatically
have its tree updated.

Insteading of passing the tree path to the wrapper when we do operations
that require calls to the tree observer (which needs to pass the tree path),
the wrappers could build the path as they are created.

Maybe each wrapper should have a pointer to its parent wrapper and keep
its own index.  We can build a tree path from a wrapper by using its
index and following its parent wrappers.

We don't want to assume that the world has an empty path.  We may want
to allow multiple worlds.

* We could have a virtual path() method, so that each child can override
  how the path is determined.  Most children are going to determine the
  path in the same way though.  The WorldWrapper will be an exception where
  it will just return the path that was given to it when it was first
  created.
