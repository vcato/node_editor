I'm looking at how dataflow expression editing can be added to charmapper.
One of the main ideas is that we can have three modes for editing expressions:
* Interactive mode
  * There are predefined expression types and all the inputs for that
    expression type are presented like a propery editor.
* Expression mode
  * A text area is provided to type in the expression.
  * Expressions are
    a = b + c;
    d = e + f;
    a + d
* Node mode
  * The expression is represented as a set of nodes that represent
    an expression tree.
  * Each node has a single output and zero or more inputs.
  * Outputs can be expanded to extract members.
  * The default operation for dragging on a node is making a connection.
    * Moving a node involves selecting it, which produces something like
      a title-bar that you can drag to move the node.
---
If we have an input that is a function, it feels like an output.  For
example, if we have an "if" expression, the "then" and "else" parts are
parameters which specify functions to evaluate, but they feel like
outputs.

Drawing a square

draw(square(a,b))

let square(lower_left_corner,upper_right_corner) = (
  let min_x = lower_left_corner.x;
  let min_y = lower_left_corner.y;
  let max_x = upper_right_corner.x;
  let max_y = upper_right_corner.y;
  let upper_left_corner = Point(x=min_x,y=max_y);
  let lower_right_corner = Point(x=max_x,y=min_y);
  let left_edge = Line(start=upper_left_corner,end=lower_left_corner);
  let right_edge = Line(start=lower_right_corner,end=upper_right_corner);
  let top_edge = Line(start=upper_right_corner,end=upper_left_corner);
  let bottom_edge = Line(start=lower_left_corner,end=lower_right_corner);
  [
    left_edge,
    right_edge,
    top_edge,
    bottom_edge
  ]
)

let lines_for_square(lower_left_corner,upper_right_corner) = (
  let Point = Object;
  let Line = Object;
  let (
    let (
      let min_x = lower_left_corner.x;
      let min_y = lower_left_corner.y;
      let max_x = upper_right_corner.x;
      let max_y = upper_right_corner.y;
      upper_left_corner = Point(x=min_x,y=max_y),
      lower_right_corner = Point(x=max_x,y=min_y)
    );
    left_edge = Line(start=upper_left_corner,end=lower_left_corner),
    right_edge = Line(start=lower_right_corner,end=upper_right_corner),
    top_edge = Line(start=upper_right_corner,end=upper_left_corner),
    bottom_edge = Line(start=lower_left_corner,end=lower_right_corner)
  )
  [
    left_edge,
    right_edge,
    top_edge,
    bottom_edge
  ]
)

---
I like the way this looks:
  http://rawkes.com/media/noflo-introduction/quartz-composer.png

Maybe I should work on a node system that has both inputs and outputs.
Inputs are names.
Outputs are expressions.
Seems like you could do a decent amount with just that.
----
Nodes have regular inputs and outputs on the left and right.
Nodes have an environment input on the top and an environment output on
the bottom.

A special code node contains internal logic.
It only has one output, which is the code.
Internally, it has an env input at the top and an env output at the bottom.

Let's call it a block.

You can have text blocks or diagram blocks.

{a = x;b = y;} // text block

A block is a function which takes an environment and returns an environment.

Functions can be created from blocks:
  function(inputs=['x','y'],outputs=['a','b'],code={a=x;b=y;})

You could have a node which was a sequence of statements.

  *|let x = $| 
  *|let y = $| 
   |      x+y|*

$ represents an input.  If the $ appears in the statement, then there is
an input connector there.
If the statement has a value, then an output connector appears.

A statement may have both an input and an output connector.
  *|$ + 5|*

Example of extracting x,y members from a point:

  *|let p = $|
   |      p.x|*
   |      p.y|*

It seems like we have two basic operations: Abstract and Apply.
Abstract creates a function, Apply applies a function.

Visually, we can takes nodes and abstract them, which creates a function
which takes an environment and returns and environment.


function(inputs=['a','b'],outputs=['x','y'],code={x=a;y=b;})(a=1,b=2)

this produces the tuple (x=1,y=2)

We can have a function node, we coverts a block into a function.

* Creating a block
* Creating a function from a block
* Applying a function

*|let a=$|
*|let b=$|
     |
  |a + b|*

We have to be careful about scope.  Do we want a statement node to return 
a modified verison of the original environment, or to return a new
environment?


*|x=input   |
*|y=input   |
 |output x+y|*

*|condition=input                                  |
*|then_block=input                                 |
*|else_block=input                                 |
 |then_block(env) if condition else else_block(env)|*

*|if input:  |
*|  exec     |
 |else:      |
*|  exec     |

 |ikPos(         |
*|  global=input,|
*|  local=input, |
*|  weight=input |
 |)              |

 |output list(|*
*|  input,    |
*|  input,    |
*|  input     |
 |)           |

Maybe if we have an output inside a loop, it creates a list:

  *|for x in input:|
   |  output x     |*--*|list(*input)|*

Inputting an outputting lists:

  *|let [x,y,z]=input   |
   |      output [z,y,x]|*

We could have special connectors which look like outputs, but are actually
inputs.  They form a block from whatever they are connected to.

Should we have a scope node that creates a new environment with the current
environment as its parent?

|let y = 4      |
|let x = 4      |
|scope{continue}|*----+
|output y       |*----|---- (6)
|output x       |*----|---- (4)
                      *
                 |let x = 5|
                 |y = 6    |


If we have continuations, can we create blocks like this?

      |let block={continue}|*---- (connect to nodes which form the block)
      |        output block|*---- (this is the resulting block)


 *|let yes=input                  |
 *|let no=input                   |
 *|let condition=input            |
  |output yes if condition else no|*

If nodes become disconnected because we temporarily have an invalid value,
it is inconvenient.

Maybe we hold on the the connection if there is one, but otherwise, we
add or remove the connector on each keystroke.


I think I want to start integrating this with Qt widgets.
I want to be able to add a slider, then put in some logic that does something
with the slider, and then show the result.

Maybe something where we add three sliders for R,G,B, then use a diagram
to turn those into a color, and then display the color.
---
It seems appealing to have it where the items in the tree represent
expressions, and the child items represent variables that can be used in
those expressions.
---
Need to have named inputs.
Maybe the inputs should be independent of the lines:
i.e. if you use $a on various lines, they all refer to the same input.
---
Maybe if we right-click on X we get a menu that lets us convert it to
a diagram.
---
It would be neat if you could select some text in a node, then drag it out
and have it create a new node with the text, replace the text in the original
node with a $ and attach the new node's output to a new input connector.
---
Eventually.  I think we'll want to be able to have diagrams that generate
new items in the tree.  I can imagine a diagram whose output is a list of
tree items.

Let's say we wanted to create a spline, and then generate a baked version
of that spline that then goes into the tree.

Or we want to create a tool that lets you add a new key to the spline.

Maybe a good thing to work on is being able to draw a spline.
We'll need a way to create a window, create a drawing area within the
window, and then provide a diagram that generates what we will draw.
---
Need to be able to be notified when the x/y coordinates of a Point2D
change so the scene can be redrawn.
