I'm looking at how dataflow expression editing can be added to charmapper.
One of the main ideas is that we can have three modes for editing expressions:
* Interactive mode
  * There are predefined expression types and all the inputs for that
    expression type are presented like a propery editor.
* Expression mode
  * A text area is provided to type in the expression.
  * Expressions are
    a = b + c;
    d = e + f;
    a + d
* Node mode
  * The expression is represented as a set of nodes that represent
    an expression tree.
  * Each node has a single output and zero or more inputs.
  * Outputs can be expanded to extract members.
  * The default operation for dragging on a node is making a connection.
    * Moving a node involves selecting it, which produces something like
      a title-bar that you can drag to move the node.
----
Nodes have regular inputs and outputs on the left and right.
Nodes have an environment input on the top and an environment output on
the bottom.

A special code node contains internal logic.
It only has one output, which is the code.
Internally, it has an env input at the top and an env output at the bottom.

Let's call it a block.

You can have text blocks or diagram blocks.

{a = x;b = y;} // text block

A block is a function which takes an environment and returns an environment.

Functions can be created from blocks:
  function(inputs=['x','y'],outputs=['a','b'],code={a=x;b=y;})

*|condition=$                        |
*|then_block=$                       |
*|else_block=$                       |
 |if(condition,then_block,else_block)|*

*|if input:  |
*|  exec     |
 |else:      |
*|  exec     |

Maybe if we have an output inside a loop, it creates a list:

  *|for x in input:|
   |  output x     |*--*|list(*input)|*

Inputting an outputting lists:

  *|let [x,y,z]=input   |
   |      output [z,y,x]|*

We could have special connectors which look like outputs, but are actually
inputs.  They form a block from whatever they are connected to.

Should we have a scope node that creates a new environment with the current
environment as its parent?

|let y = 4      |
|let x = 4      |
|scope{continue}|*----+
|output y       |*----|---- (6)
|output x       |*----|---- (4)
                      *
                 |let x = 5|
                 |y = 6    |


If we have continuations, can we create blocks like this?

      |let block={continue}|*---- (connect to nodes which form the block)
      |        output block|*---- (this is the resulting block)


 *|let yes=input                  |
 *|let no=input                   |
 *|let condition=input            |
  |output yes if condition else no|*

I think I want to start integrating this with Qt widgets.
I want to be able to add a slider, then put in some logic that does something
with the slider, and then show the result.

Maybe something where we add three sliders for R,G,B, then use a diagram
to turn those into a color, and then display the color.
---
It would be neat if you could select some text in a node, then drag it out
and have it create a new node with the text, replace the text in the original
node with a $, and attach the new node's output to a new input connector.
---
Maybe a good thing to work on is being able to draw a spline.
We'll need a way to create a window, create a drawing area within the
window, and then provide a diagram that generates what we will draw.
---
If a node in a diagram gets wider, it should push nodes that are connected
to it to the right.
---
Be able to remove variable min/max
---
Inputs aren't clearly associated with lines.
* If you have two lines, and the first line has no inputs, and the second
  line has two inputs, it looks like the first input goes with the first
  line and the second input goes with the second line.  It would be better
  if the lines were spaced such that it was clear which inputs went with
  each line.

Seems like we need a better way of doing layouts.
* We could make a bunch of nested boxes where we had one box for each thing we
  needed to lay out,  We then lay out those boxes, then put each thing
  in it's box.

* Seems like the logic we have currently is fine if we were only dealing
  with one line, so maybe we just use the current logic separately on each
  line, then put together all the results.
  * That isn't quite right because we want all the output connectors to line
    up on the right side.

working with the text objects is a bit awkward.  We're creating text objects,
then making rectangles based on the text objects, then making other text
objects based on these rectangles.  It would be easier if we were just
dealing with rectangles, and then fitting the text objects into the rectangles
later.  Seems like this could work if we had a convention, like that the
upper left corner of the rectangle specifies the text object location.


I think it would be best to make a series of sizes.  We'll start at
a low level with the sizes of the indivudal text lines and input
connectors.  We'll build up the vertical sizes of the lines, and the
horizontal size.  Once all sizes are determined, we'll go back and
lay out everything from the top back down to the individual items.


// We can define the positions inductively like this:
given:
  line_n_inputs[i]
  line_text_heights[i]
  line_text_widths[i]
  connector_width
  connector_height
  left_x
  top_y

calculate:
  input_heights[i] = connector_height*line_n_inputs[i]
  region_heights[i] = max(input_heights[i],line_text_heights[i])
  body_height = sum{i}(region_heights[i])
  body_width = max{i}(line_text_widths[i])
  region_x[i] = left_x
  region_y[0] = top_y
  region_y[i+1] = region_y[i] - region_height[i]
  input_x[i] = left_x - connector_width

  first_input_index[0] = 0
  first_input_index[i+1] = first_input_index[i] + line_n_inputs[i]

  input_y[first_input_index[i]] =
    region_y[i] + (region_heights[i] - input_heights[i])/2

  input_y[first_input_index[i]+a+1] =
    input_y[first_input_index[i]+a] + input_height

  line_y[i] = region_y[i] - (region_heights[i] - line_text_heights[i])/2

  output_width[i] = connector_width
  output_height[i] = connector_height
  output_x[i] = region_x[i] + region_width[i]
  output_y[i] = region_y[i] - (region_heights[i] - connector_height)/2
  input_width[i] = connector_width
  input_height[i] = connector_height

results:
  line_x[i]
  line_y[i]
  input_x[j]
  input_y[j]
  input_width[j]
  input_height[j]
  output_x[k]
  output_y[k]
  output_width[k]
  output_height[k]

The top function we need to modify is DiagramEditor::nodeRenderInfo()
